#!/bin/bash

function die {
 echo $1 >&2
 exit 1
}

function fixsubj {
#add on sub- if not exists
subj=$1
 if [ ! "${subj:0:4}" = "sub-" ]
 then
  subj="sub-$subj"
 fi
 echo $subj
}

function fixsess {
#add on ses- if not exists
sess=$1
 if [ ! "${sess:0:4}" = "ses-" ]
 then
  sess="sub-$sess"
 fi
 echo $sess
}





execpath=`dirname $0`
execpath=`realpath $execpath`

in_brainmask_dir=
in_fmriprep_dir=


subject_label_dir=
subject_label_match=
subject_label_csv=
subject_label_name=


in_atlas_dir=$execpath/atlases

matching_dwi=
participant_label=

nodenoise=0
nounring=0
notopup=0
noeddy=0
nodistcorr=0
noregT1=0
nodke=0
nobedpost=0
nogradcorr=1

matching_T1w=
n_cpus=8
reg_init_subj=
grad_coeff_file=
scratch_dir=

resample_res=

#default:
atlas=dosenbach

atlas_space=MNI152_1mm
#atlas_label_nii=dosenbach/dos160_roi_atlas.nii.gz
#atlas_label_csv=dosenbach/dos160_roi_atlas.csv

nprobseeds=5000
session_ID=* #For participant2 level (If --session is not defined, it will run on all sessions)
matrix=FA #default, use FA
threshold=0.01 # calculate FA in voxels with that at least 1% of streamline pass through

if [ "$#" -lt 3 ]
then
 echo "Usage: prepdwi bids_dir output_dir {participant,group,participant2} <optional arguments>"
 echo ""
 echo " General options:"
 echo ""
 echo "          [--participant_label PARTICIPANT_LABEL [PARTICIPANT_LABEL...]]"
 echo "          [-w WORK_DIR]  (scratch directory)"
 echo "          [--n_cpus NCPUS] (default: 8) "
 echo ""
 echo " participant options:"
 echo ""
 echo "          [--matching_dwi MATCHING_PATTERN] (for selecting dwi)"
 echo "          [--matching_T1w MATCHING_STRING] (for selecting T1w)"
 echo""
 echo "          [--in_brainmask_dir BRAINMASK_DIR]  (e.g. output folder from BEaST bids app)"
 echo "          [--in_fmriprep_dir FMRIPREP_DIR]  (e.g. output folder from fmriprep bids app)"
 echo "                                            (currently just grabs skull-stripped, intensity norm T1w from fmriprep)"
 echo "                                            (requires fmriprep >= 1.3.2)"
 echo ""
 echo "          [--reg_init_participant sub-SUBJ --OR-- sub-SUBJ_ses-SES]"
 echo ""
 echo "          [--no-denoise]"
 echo "          [--no-unring]"
 echo "          [--no-topup]"
 echo "          [--no-eddy]"
 echo "          [--no-distcorr]"
 echo "          [--no-regT1]"
 echo "                [--resample_res ISOTROPIC_RES_IN_MM]  (default uses native resolution)"
 echo "          [--no-gradcorr]"
 echo "                [--grad_coeff_file GRAD_COEFF_FILE]"
 echo ""
 echo "          [--no-dke]"
 echo "          [--no-bedpost]"
 echo ""
 echo ""
 echo " participant2 (probtrack connectivity with atlas-space labels) options:"
 echo ""
 echo "          [--nprobseeds N ] (for probtrackx, default: 5000) "
 echo ""
 echo "          [--matrices NAME (Additional matrices: FSL_FA, FSL_MD, DKE_FA, etc, default: $matrix)"
 echo "          [--threshold TH (Threshold from 0-1, fraction of streamlines to get pathway mask, default: $threshold)"
 echo ""
 echo "      Choose built-in atlas:"
 echo "          [--atlas NAME ] (default: dosenbach)"
 echo ""
 echo "       Available built-in atlas labels/csv:"
 pushd $execpath/cfg > /dev/null
echo -n "          "; 
ls *
popd > /dev/null
 echo "   "
 echo "       Customize atlas labels:"
 echo "          {--atlas_space NAME (MNI152_1mm or MNI152NLin2009cAsym)"
 echo "          [--atlas_label_nii NIFTI" 
 echo "          [--atlas_label_csv LABEL_INDEX_CSV"
 echo ""
 echo " participant3 (probtrack connectivity with imported subject T1w-space labels) options:"
 echo ""
 echo "      Required:"
 echo "          [--subject_label_name NAME]  (shorthand name for output files, e.g.: freesurfer)"
 echo "          [--subject_label_dir SUBJ_LABEL_DIR]  (root folder containing paths to labels in subj T1w space, e.g.: mybids/derivatives/freesurfer"
 echo "          [--subject_label_match MATCHING_STRING]  (string to identify subject label file (assumed nii.gz), e.g.:  aparc+aseg)"
 echo "          [--subject_label_csv LABEL_INDEX_CSV]  (csv file with name,number for each ROI to include, e.g.: )"
 echo ""
 echo "      Optional:"
 echo "          [--nprobseeds N ] (for probtrackx, default: 5000) "

 exit 1
fi


#=====================================================================
#---------------------  ARGUMENT PARSING -----------------------------
#=====================================================================

in_bids=$1 
out_folder=$2 
analysis_level=$3


shift 3

while :; do
      case $1 in
     -h|-\?|--help)
	     usage
            exit 1
              ;;
    --no-denoise )
	nodenoise=1;;
    --no-unring )
	nounring=1;;
    --no-topup )
	notopup=1;;
    --no-eddy )
	noeddy=1;;
    --no-distcorr )
	nodistcorr=1;;
    --no-regT1 )
	noregT1=1;;
    --no-gradcorr )
	nogradcorr=1;;
    --no-bedpost )
	nobedpost=1;;
     --no-dke )
	nodke=1;;
     --n_cpus )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                n_cpus=$2
                  shift
	      else
              die 'error: "--n_cpus" requires a non-empty option argument.'
            fi
              ;;
     -w )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                scratch_dir=$2
                  shift
	      else
              die 'error: "-w" requires a non-empty option argument.'
            fi
              ;;
     --participant_label )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                participant_label=$2
                  shift
	      else
              die 'error: "--participant" requires a non-empty option argument.'
            fi
              ;;
     --participant_label=?*)
          participant_label=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --participant_label=)         # handle the case of an empty --participant=
         die 'error: "--participant_label" requires a non-empty option argument.'
          ;;
     --matching_dwi )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_dwi=$2
                  shift
	      else
              die 'error: "--matching_dwi" requires a non-empty option argument.'
            fi
              ;;
     --matching_dwi=?*)
          matching_dwi=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_dwi=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;
     --matching_T1w )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_T1w=$2
                  shift
	      else
              die 'error: "--matching_T1w" requires a non-empty option argument.'
            fi
              ;;
     --matching_T1w=?*)
          matching_T1w=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_T1w=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;


      --reg_init_participant )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                reg_init_subj=$2
                  shift
	      else
              die 'error: "--reg_init_participant" requires a non-empty option argument.'
            fi
              ;;
     --reg_init_participant=?*)
          reg_init_subj=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --reg_init_participant=)         # handle the case of an empty --participant=
         die 'error: "--reg_init_participant" requires a non-empty option argument.'
          ;;


       --grad_coeff_file )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                grad_coeff_file=$2
                  shift
                  nogradcorr=0
	      else
              die 'error: "--grad_coeff_file" requires a non-empty option argument.'
            fi
              ;;
     --grad_coeff_file=?*)
          grad_coeff_file=${1#*=} # delete everything up to "=" and assign the remainder.
          nogradcorr=0
            ;;
          --grad_coeff_file=)         # handle the case of an empty --participant=
         die 'error: "--grad_coeff_file" requires a non-empty option argument.'
          ;;

      --resample_res )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                resample_res=$2
                  shift
	      else
              die 'error: "--resample_res" requires a non-empty option argument.'
            fi
              ;;
     --resample_res=?*)
          resample_res=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --resample_res=)         # handle the case of an empty --participant=
         die 'error: "--resample_res" requires a non-empty option argument.'
          ;;

      --in_brainmask_dir )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                in_brainmask_dir=$2
                  shift
	      else
              die 'error: "--in_brainmask_dir" requires a non-empty option argument.'
            fi
              ;;
     --in_brainmask_dir=?*)
          in_brainmask_dir=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --in_brainmask_dir=)         # handle the case of an empty --participant=
         die 'error: "--in_brainmask_dir" requires a non-empty option argument.'
          ;;

      --in_fmriprep_dir )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                in_fmriprep_dir=$2
                  shift
	      else
              die 'error: "--in_fmriprep_dir" requires a non-empty option argument.'
            fi
              ;;
     --in_fmriprep_dir=?*)
          in_fmriprep_dir=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --in_fmriprep_dir=)         # handle the case of an empty --participant=
         die 'error: "--in_fmriprep_dir" requires a non-empty option argument.'
          ;;


      
      --atlas )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas=$2
                  shift
	      else
              die 'error: "--atlas" requires a non-empty option argument.'
            fi
              ;;
     --atlas=?*)
          atlas=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas=)         # handle the case of an empty --participant=
         die 'error: "--atlas" requires a non-empty option argument.'
          ;;



      --matrices )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matrix=$2
                  shift
	      else
              die 'error: "--matrices" requires a non-empty option argument.'
            fi
              ;;
     --matrices=?*)
          matrix=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matrices=)         # handle the case of an empty --matrices=
         die 'error: "--matrices" requires a non-empty option argument.'
          ;;



      --threshold )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                threshold=$2
                  shift
	      else
              die 'error: "--session" requires an existing session name.'
            fi
              ;;
     --threshold=?*)
          session_ID=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --threshold=)         # handle the case of an empty --threshold=
         die 'error: "--session" requires a non-empty option argument.'
          ;;

      
      --atlas_label_nii )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_label_nii=$2
                  shift
	      else
              die 'error: "--atlas_label_nii" requires a non-empty option argument.'
            fi
              ;;
     --atlas_label_nii=?*)
          atlas_label_nii=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_label_nii=)         # handle the case of an empty --participant=
         die 'error: "--atlas_label_nii" requires a non-empty option argument.'
          ;;


      --atlas_label_csv )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_label_csv=$2
                  shift
	      else
              die 'error: "--atlas_label_csv" requires a non-empty option argument.'
            fi
              ;;
     --atlas_label_csv=?*)
          atlas_label_csv=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_label_csv=)         # handle the case of an empty --participant=
         die 'error: "--atlas_label_csv" requires a non-empty option argument.'
          ;;


      --atlas_space )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_space=$2
                  shift
	      else
              die 'error: "--atlas_space" requires a non-empty option argument.'
            fi
              ;;
     --atlas_space=?*)
          atlas_space=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_space=)         # handle the case of an empty --participant=
         die 'error: "--atlas_space" requires a non-empty option argument.'
          ;;

      --subject_label_dir )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                subject_label_dir=$2
                  shift
	      else
              die 'error: "--subject_label_dir" requires a non-empty option argument.'
            fi
              ;;
     --subject_label_dir=?*)
          subject_label_dir=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --subject_label_dir=)         # handle the case of an empty --participant=
         die 'error: "--subject_label_dir" requires a non-empty option argument.'
          ;;

     --subject_label_match )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                subject_label_match=$2
                  shift
	      else
              die 'error: "--subject_label_match" requires a non-empty option argument.'
            fi
              ;;
     --subject_label_match=?*)
          subject_label_match=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --subject_label_match=)         # handle the case of an empty --participant=
         die 'error: "--subject_label_match" requires a non-empty option argument.'
          ;;

      --subject_label_csv )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                subject_label_csv=$2
                  shift
	      else
              die 'error: "--subject_label_csv" requires a non-empty option argument.'
            fi
              ;;
     --subject_label_csv=?*)
          subject_label_csv=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --subject_label_csv=)         # handle the case of an empty --participant=
         die 'error: "--subject_label_csv" requires a non-empty option argument.'
          ;;

      --subject_label_name )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                subject_label_name=$2
                  shift
	      else
              die 'error: "--subject_label_name" requires a non-empty option argument.'
            fi
              ;;
     --subject_label_name=?*)
          subject_label_name=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --subject_label_name=)         # handle the case of an empty --participant=
         die 'error: "--subject_label_name" requires a non-empty option argument.'
          ;;


     --nprobseeds )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                nprobseeds=$2
                  shift
	      else
              die 'error: "--nprobseeds" requires a non-empty option argument.'
            fi
              ;;


      -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
              ;;
     *)               # Default case: No more options, so break out of the loop.
          break
    esac
  
 shift
  done


shift $((OPTIND-1))

#=====================================================================
#--------------------- SET-UP VARIABLES  -----------------------------
#=====================================================================

echo matching_dwi=$matching_dwi
echo participant_label=$participant_label

if [ -e $in_bids ]
then
	in_bids=`realpath $in_bids`
else
	echo "ERROR: bids_dir $in_bids does not exist!"
	exit 1
fi

if [ -n "$grad_coeff_file" ]
then
        if [ -e $grad_coeff_file ]
        then
            grad_coeff_file=`realpath $grad_coeff_file`
        else
            echo "grad_coeff_file $grad_coeff_file does not exist! exiting!"
            exit 1
        fi
fi

#exports for scripts to make use of
export scratch_dir


if [ -n "$in_brainmask_dir" ]
then

 if [ ! -e $in_brainmask_dir ]
 then
    echo "Input brainmask dir $in_brainmask_dir does not exist! exiting.."
    exit 1
 fi

 in_brainmask_dir=`realpath $in_brainmask_dir`
 custom_brainmask=1
 searchstring_brainmask=*T1w*brain.nii.gz #skull-stripped intensity normalized T1w

else
 custom_brainmask=0

fi


if [ -n "$in_fmriprep_dir" ]
then

 if [ ! -e $in_fmriprep_dir/fmriprep ]
 then
    echo "Input fmriprep dir $in_fmriprep_dir/fmriprep does not exist! exiting.."
    exit 1
 fi

 in_fmriprep_dir=`realpath $in_fmriprep_dir/fmriprep`
 in_brainmask_dir=$in_fmriprep_dir
 custom_brainmask=1
 searchstring_brainmask=*desc-preproc_T1w.nii.gz #skull-stripped intensity normalized T1w
else
 custom_brainmask=0

fi






participants=$in_bids/participants.tsv

work_folder=$out_folder/work
derivatives=$out_folder #bids derivatives

mkdir -p $work_folder $derivatives
derivatives=`realpath $derivatives`

#just in case participants.tsv does not exist:
if [ ! -e $participants ]
then
    #participants tsv not required by bids, so if it doesn't exist, create one for temporary use
    participants=$work_folder/participants.tsv
    echo participant_id > $participants
    participants=`realpath $participants`
    pushd $in_bids
    ls -d sub-* >> $participants
    popd 
fi



if [ -n "$participant_label" ]
then
subjlist=`echo $participant_label | sed  's/,/\ /g'` 
else
subjlist=`tail -n +2 $participants | awk '{print $1}'`
fi


if [ -e $atlas ]
then
  echo "sourcing external atlas config: $atlas"
  source $atlas
elif [ -e $execpath/cfg/$atlas ]
then
  echo "sourcing internal atlas config: $atlas"
  source $execpath/cfg/$atlas
else
  echo "atlas config file $execpath/cfg/$atlas does not exist!"
  exit 1
fi

if [ ! "$analysis_level" = "participant3" ]
then

#use symlinks instead of copying 
for atlas_dir in `ls -d $in_atlas_dir/*`
do
 atlas_name=${atlas_dir##*/}

#first, for backwards compatibility, if it is a symlink, then remove it first
if [[ -L "$work_folder/$atlas_name" && -e "$work_folder/$atlas_name" ]]
then
  rm -f $work_folder/$atlas_name
fi

#if the directory exists already, then copy into it
if [ -e $work_folder/$atlas_name ]
then
echo "Copying $atlas_name to existing atlas work folder:"
cp -R $atlas_dir/* $work_folder/$atlas_name
else
echo "Copying $atlas_name to new atlas work folder:"
cp -R $atlas_dir $work_folder/$atlas_name
fi

done
fi

#=====================================================================
#--------------------- BEGIN STAGE:  participant  --------------------
#=====================================================================

if [ "$analysis_level" = "participant" ]
then
 echo " running participant level analysis"


pushd $work_folder
echo $participants

if [ -n "$matching_dwi" ]
then
  searchstring_dwi=\*${matching_dwi}\*dwi.nii*
else
  searchstring_dwi=*dwi.nii*
fi

if [ -n "$matching_T1w" ]
then
  searchstring_t1w=\*${matching_T1w}\*T1w.nii*
else
  searchstring_t1w=*T1w.nii*
fi

t1_img_type=t1/t1.brain.inorm.nii.gz

for subj in $subjlist 
do

    #add on sub- if not exists
    subj=`fixsubj $subj`

    #loop over sub- and sub-/ses-
    for subjfolder in `ls -d $in_bids/$subj/dwi $in_bids/$subj/ses-*/dwi 2> /dev/null`
    do

        subj_sess_dir=${subjfolder%/dwi}
        subj_sess_dir=${subj_sess_dir##$in_bids/}
        if echo $subj_sess_dir | grep -q '/'
        then
            sess=${subj_sess_dir##*/}
            subj_sess_prefix=${subj}_${sess}
        else
            subj_sess_prefix=${subj}
        fi
        echo subjfolder $subjfolder
        echo subj_sess_dir $subj_sess_dir
        echo sess $sess
        echo subj_sess_prefix $subj_sess_prefix


#========================================================================
#========================================================================
#-- T1w Pre-processing steps:
#========================================================================
#========================================================================



if [ "$custom_brainmask" = 1 ]
then

t1w_in_brainmask=`eval ls $in_brainmask_dir/$subj_sess_dir/anat/${subj_sess_prefix}${searchstring_brainmask} | head -n 1`

if [ -e $t1w_in_brainmask ]
then
	echo "Using pre-computed skull-stripped image..."
	echo mkdir -p $subj_sess_prefix/t1
	mkdir -p $subj_sess_prefix/t1
	echo cp -v $t1w_in_brainmask $subj_sess_prefix/t1/t1.brain.inorm.nii.gz
	cp -v $t1w_in_brainmask $subj_sess_prefix/t1/t1.brain.inorm.nii.gz
fi

fi


N_t1w=`eval ls $in_bids/$subj_sess_dir/anat/${subj_sess_prefix}${searchstring_t1w} | wc -l`
in_t1w=`eval ls $in_bids/$subj_sess_dir/anat/${subj_sess_prefix}${searchstring_t1w} | head -n 1`

if [ "$N_t1w" = 0 ]
then
	
	echo "--- No T1w images found in $in_bids/$subj_sess_dir/anat ---"

	if [ "$custom_brainmask" = 0 ]
	then
	echo "	automatically setting --no-regT1"
		noregT1=1
	fi
fi



if [ "$noregT1" = 1 ]
then
	echo "--- T1w pre-preprocessing disabled (--no-regT1) "
else


if [ ! -e $subj_sess_prefix/t1/t1.nii.gz ]
then
 echo --- Running importT1 ---
 echo Found $N_t1w matching T1w, using first found: $in_t1w
 echo $execpath/bin/importT1 $in_t1w $subj_sess_prefix
 $execpath/bin/importT1 $in_t1w $subj_sess_prefix
else
 echo --- Skipping importT1 ---
fi


#preprocess T1w internally
if [ ! -e $subj_sess_prefix/${t1_img_type} ] &&  [ "$custom_brainmask" = 0 ]
then
echo --- Running preprocT1 ---
	echo $execpath/bin/preprocT1 $subj_sess_prefix
	 $execpath/bin/preprocT1 $subj_sess_prefix
 else
	echo --- Skipping preprocT1 ---
fi

#register t1 to atlases
for atlas_dir in `ls -d $in_atlas_dir/*`
do
 atlas_name=${atlas_dir##*/}



if [ -n "$reg_init_subj" ]
then

 #add on sub- prefix if it doesn't exist
 reg_init_subj=`fixsubj $reg_init_subj`

 echo --- Running atlas affine registration initialized with $reg_init_subj xfm ---
 echo $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix -i $reg_init_subj
 $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix -i $reg_init_subj
 echo --- Running atlas b-spline registration ---
 echo $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
 $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix

 else
     
 if [ ! -e $subj_sess_prefix/reg/affine_aladin_t1/${atlas_name}_$subj_sess_prefix/${atlas_name}_to_${subj_sess_prefix}.xfm ] || [ "$custom_brainmask" = 1 ]
 then
 echo --- Running atlas affine registration ---
 echo $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix 
 $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix 
 else 
 echo --- Skipping atlas affine registration ---
 fi

 if [ ! -e $subj_sess_prefix/reg/bspline_f3d_t1/${atlas_name}_$subj_sess_prefix/ctrlpt_${atlas_name}_to_${subj_sess_prefix}.nii.gz ] || [ "$custom_brainmask" = 1 ]
 then
    echo --- Running atlas b-spline registration ---
    echo $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
    $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
 else 
  echo --- Skipping atlas b-spline registration ---

 fi


 fi # if [ -n "$reg_init_subj" ]


 #remove link to atlas after running -- don't do this, as other parallel runs may be using it!!

# rm $atlas_name


done #atlas_dir

fi #N_t1w=0


#========================================================================
#========================================================================
#-- DWI Pre-processing steps:
#========================================================================
#========================================================================


#========================================================================
# import
#========================================================================

 Ndwi=`eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi} | wc -l`

 #thisdisable not defined since import step cannot be skipped 
 thisstep=uncorrected
 thisproduces=$subj_sess_prefix/dwi/${thisstep}/dwi_$Ndwi.nii.gz



    if [ ! -e $thisproduces ]
    then
        echo "--- Running import into $thisstep  ---"
        echo Ndwi=$Ndwi
        echo Found $Ndwi matching dwi, using all: 
        eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}

        echo "$execpath/bin/importDWI ${thisstep}  $Ndwi `eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}` $subj_sess_prefix "
        $execpath/bin/importDWI ${thisstep}  $Ndwi `eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}` $subj_sess_prefix 

    else

        echo "--- $thisstep already run ---"
    fi

 if [ ! -e $thisproduces ]
 then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
 fi

 prevstep=${thisstep}


#========================================================================
# denoise
#========================================================================

 thisdisable=$nodenoise
 thisstep=denoise
 thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi_$Ndwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processDwiDenoise $prevstep $subj_sess_prefix
        $execpath/bin/processDwiDenoise $prevstep $subj_sess_prefix
    else

        echo "--- $thisstep already run ---"
    fi
  
  if [ ! -e $thisproduces ]
 then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
 fi

   
    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# unring
#========================================================================

 thisdisable=$nounring
 thisstep=unring
 thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi_$Ndwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processUnring $prevstep $subj_sess_prefix
        $execpath/bin/processUnring $prevstep $subj_sess_prefix
    else

        echo "--- $thisstep already run ---"
    fi

    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi


    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# topup
#========================================================================

#disable topup if only one dwi
if [ "$Ndwi" = "1" ]
then
    notopup=1
fi

 thisdisable=$notopup
 thisstep=topup
 thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else

    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processTopUp $prevstep $subj_sess_prefix
        $execpath/bin/processTopUp $prevstep $subj_sess_prefix
    else

        echo "--- $thisstep already run ---"
    fi

    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# eddy (after topup)
#========================================================================


#if topup or eddy is disabled, then disable this topup initialized eddy
if [ "$notopup" = "1" ] || [ "$noeddy" = "1" ]
then
    thisdisable=1
else
    thisdisable=0
fi

thisstep=eddy
thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
     echo "--- ${thisstep} (no top-up) disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        $execpath/bin/processEddy ${prevstep} $subj_sess_prefix 
    else
	    echo "--- $thisstep (no topup) already run ---"
    fi
 
    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    
    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# eddy (no topup)
#========================================================================

#if topup is disabled, but eddy is not, then proceed
if [ "$notopup" = "1" ] && [ "$noeddy" = "0" ]
then
    thisdisable=0
else
    thisdisable=1
fi

thisstep=eddy
thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        $execpath/bin/processEddyNoTopUp ${prevstep} $subj_sess_prefix
    else
        echo "--- $thisstep already run ---"
    fi
 
    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    
    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# distcorr (when no topup)
#========================================================================

#if topup is disabled, but eddy is not, then proceed
if [ "$notopup" = "1" ] && [ "$nodistcorr" = "0" ]
then
    thisdisable=0
else
    thisdisable=1
fi

thisstep=dc
thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else

    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processDistortCorrect ${prevstep} $subj_sess_prefix
        $execpath/bin/processDistortCorrect ${prevstep} $subj_sess_prefix
    else
        echo "--- $thisstep already run ---"
    fi

    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable


#========================================================================
# regT1 (linear reg to T1w)
#========================================================================

 thisdisable=$noregT1
 thisstep=regT1
 thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processRegT1 ${prevstep} $subj_sess_prefix $resample_res
        $execpath/bin/processRegT1 ${prevstep} $subj_sess_prefix $resample_res
    else

        echo "--- $thisstep already run ---"
    fi
 
    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    
    prevstep=${prevstep}_${thisstep}

    echo "Setting symlink for regT1 preprocessed dwi work dir"
    ln -srfvn $subj_sess_prefix/dwi/$prevstep $subj_sess_prefix/dwi/proc_regT1

 fi #if thisdisable


#========================================================================
# gradCorr 
#========================================================================

 thisdisable=$nogradcorr
 thisstep=gradCorr
 thisproduces=$subj_sess_prefix/dwi/${prevstep}_${thisstep}/dwi.nii.gz

 if [ "$thisdisable" = "1" ]
 then
     prevstep=$prevstep
    echo "--- ${thisstep} disabled ---"
 else


    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processGradUnwarp ${prevstep} $grad_coeff_file $noregT1 $subj_sess_prefix
        $execpath/bin/processGradUnwarp ${prevstep} $grad_coeff_file $noregT1 $subj_sess_prefix
    else

        echo "--- $thisstep already run ---"
    fi
 
    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi

    
    prevstep=${prevstep}_${thisstep}

 fi #if thisdisable



#========================================================================
# now all DWI pre-processing steps complete, create symlink to final step

processed=$prevstep
echo "Setting symlink for final preprocessed dwi work dir"
ln -srfvn $subj_sess_prefix/dwi/$prevstep $subj_sess_prefix/dwi/processed

#========================================================================





#========================================================================
#========================================================================
#-- DWI Post-processing steps:
#========================================================================
#========================================================================



#========================================================================
# check if multi-shell
#========================================================================

  bval=$subj_sess_prefix/dwi/$processed/dwi.bval
  shells=$subj_sess_prefix/dwi/$processed/dwi.shells

 if [ ! -e $shells ]
 then
  echo "Checking number of shells..."
  echo octave --path $execpath/octave --eval "writeShellsFromBval('$bval','$shells')"
  octave --path $execpath/octave --eval "writeShellsFromBval('$bval','$shells')"
 fi

  nshells=`cat $shells | wc -l`
  if [ "$nshells" -gt 1 ]
  then
      echo "--- Multi-shell DWI detected ---"
       is_multishell=1
       cat $shells
   else
      echo "--- Single-shell DWI detected ---"
       is_multishell=0
  fi


#========================================================================
# generate mean DWI for each shell
#========================================================================

for shell in `cat $shells`
do

  echo octave --eval "extractMeanDWI('$subj_sess_prefix/dwi/$processed/dwi',$shell,'$subj_sess_prefix/dwi/$processed/avgDWI_bval-${shell}.nii.gz')"
  octave --eval "extractMeanDWI('$subj_sess_prefix/dwi/$processed/dwi',$shell,'$subj_sess_prefix/dwi/$processed/avgDWI_bval-${shell}.nii.gz')"

done

#========================================================================
# bedpost
#========================================================================
 thisdisable=$nobedpost
 thisstep=bedpost
 thisproduces=$subj_sess_prefix/dwi/${processed}/$thisstep.bedpostX/dyads1.nii.gz

 if [ "$thisdisable" = "1" ]
 then
    echo "--- ${thisstep} disabled ---"
 else

    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processBedpost $n_cpus $processed $subj_sess_prefix
        $execpath/bin/processBedpost $n_cpus $processed $subj_sess_prefix
    else
        echo "--- $thisstep already run ---"
    fi

    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi


 fi #if thisdisable

#========================================================================
# DKE
#========================================================================
if [ "$nodke" = 0 ] && [  "$is_multishell" = 1 ]
then
    thisdisable=0
else
    thisdisable=1
fi

 thisstep=dke
 thisproduces=$subj_sess_prefix/dwi/${processed}_dke/kmean.nii.gz

 if [ "$thisdisable" = "1" ]
 then
    echo "--- ${thisstep} disabled ---"
 else

    if [ ! -e $thisproduces ]
    then
        echo "--- Running $thisstep  ---"
        echo $execpath/bin/processDKE $processed $subj_sess_prefix
        $execpath/bin/processDKE $processed $subj_sess_prefix
    else
        echo "--- $thisstep already run ---"
    fi

    if [ ! -e $thisproduces ]
    then
	 echo "Failed to produce $thisproduces at step ${thisstep}, exiting!"
	 exit 1
    fi


 fi #if thisdisable



#========================================================================
# cleanup BIDS (make symlinks to BIDS output)
#========================================================================

echo "--- Running processCleanupBIDS ---"
$execpath/bin/processCleanupBIDS $processed $derivatives $subj_sess_prefix




done #loop over subj/sess
done #loop over subj


popd

#=====================================================================
#---------------------- END STAGE:  participant  ---------------------
#=====================================================================


#=====================================================================
#---------------------- BEGIN STAGE:  group ---- ---------------------
#=====================================================================

elif [ "$analysis_level" = "group" ]
 then


    qc_dir=QC_`date +%Y-%m-%d_%Hh_%Mm`



    echo "generating preproc QC reports"
    #TODO: move this to a separate script

    #need to make a subjlist for this command 

    #TODO:  use GNU parallel here:

    for subj in $subjlist
    do
        subj=`fixsubj $subj`
 
    #loop over sub- and sub-/ses-
    for subjfolder in `ls -d $in_bids/$subj/dwi $in_bids/$subj/ses-*/dwi 2> /dev/null`
    do

        subj_sess_dir=${subjfolder%/dwi}
        subj_sess_dir=${subj_sess_dir##$in_bids/}
        if echo $subj_sess_dir | grep -q '/'
        then
            sess=${subj_sess_dir##*/}
            subj_sess_prefix=${subj}_${sess}
        else
            subj_sess_prefix=${subj}
        fi
        echo subjfolder $subjfolder
        echo subj_sess_dir $subj_sess_dir
        echo sess $sess
        echo subj_sess_prefix $subj_sess_prefix


   
    pushd $work_folder
    echo $execpath/bin/genOverlay_brainmask $qc_dir $subj_sess_prefix 
    $execpath/bin/genOverlay_brainmask $qc_dir $subj_sess_prefix
    echo $execpath/bin/genOverlay_mask $qc_dir dwi/processed/dwi.nii.gz dwi/processed/brainmask.nii.gz dwi_brainmask $subj_sess_prefix 
    $execpath/bin/genOverlay_mask $qc_dir dwi/processed/dwi.nii.gz dwi/processed/brainmask.nii.gz dwi_brainmask $subj_sess_prefix 

    for atlas_dir in `ls -d $in_atlas_dir/*`
    do
     atlas_name=${atlas_dir##*/}
     echo $execpath/bin/genOverlay_affine_atlasReg $qc_dir $atlas_name $subj_sess_prefix 
     $execpath/bin/genOverlay_affine_atlasReg $qc_dir $atlas_name $subj_sess_prefix 
  echo    $execpath/bin/genOverlay_bspline_atlasReg $qc_dir $atlas_name $subj_sess_prefix 
     $execpath/bin/genOverlay_bspline_atlasReg $qc_dir $atlas_name $subj_sess_prefix 
    done
    
    if [ -e $subj_sess_prefix/dwi/proc_regT1 ]
    then

    #dwi and T1 reg
    echo $execpath/bin/genOverlay_mask $qc_dir dwi/proc_regT1/dwi.nii.gz dwi/proc_regT1/epi_reg/t1_diffres.nii.gz reg_dwi_t1 $subj_sess_prefix 
    $execpath/bin/genOverlay_mask $qc_dir dwi/proc_regT1/dwi.nii.gz dwi/proc_regT1/epi_reg/t1_diffres.nii.gz reg_dwi_t1 $subj_sess_prefix 
    
    fi

    popd
   
    #combine into single html
    # copy over png files, and grep href, and make first/last line
    mkdir -p $derivatives/reports/images
    final_qc=$derivatives/reports/$subj_sess_prefix.html
    echo "<HTML><TITLE>$subj</TITLE><BODY BGCOLOR=\"#aaaaff\">" > $final_qc
    grep -h href $work_folder/$qc_dir/*/index.html >> $final_qc
    echo "</BODY></HTML>" >>$final_qc

    #move relative to images subfolder
    sed -i 's/href="/href="images\//' $final_qc
    sed -i 's/src="/src="images\//' $final_qc

    #move files and clean-up
    rm -v $work_folder/${qc_dir}/*/grot*.png
    mv -v $work_folder/${qc_dir}/*/*.png $derivatives/reports/images
    rm -v $work_folder/${qc_dir}/*/*
    rmdir -v  $work_folder/${qc_dir}/*
    rmdir -v $work_folder/${qc_dir}

    done #subj-ses

    done #subj

    # we still need QC for:
    # processing performed
    # eddy stats
    # color rgb??
    # DWI overlaid with atlas labels??

#=====================================================================
#---------------------- END STAGE:  group ----------------------------
#=====================================================================


#=====================================================================
#--------------------- BEGIN STAGE:  participant2  -------------------
#=====================================================================

 elif [ "$analysis_level" = "participant2" ]
 then

 #network connectivity matrix
 echo --- Running stage participant2:  connectivity analysis ---


 if [ -e $work_folder/$atlas_space/labels/t1/$atlas_label_nii ]
 then
     atlas_label_nii=`realpath $work_folder/$atlas_space/labels/t1/$atlas_label_nii`
 else
     if [ ! -e $atlas_label_nii ]
     then
      echo "--atlas_label_nii $atlas_label_nii does not exist!"
      exit 1
    else
     atlas_label_nii=`realpath $atlas_label_nii`
     fi
 fi

 if [ -e $work_folder/$atlas_space/labels/t1/$atlas_label_csv ]
 then
     atlas_label_csv=`realpath $work_folder/$atlas_space/labels/t1/$atlas_label_csv`
 else
     if [ ! -e $atlas_label_csv ]
     then
      echo "--atlas_label_csv $atlas_label_csv does not exist!"
      exit 1
    else
     atlas_label_csv=`realpath $atlas_label_csv`
    fi

 fi

 pushd $work_folder
  for subj in $subjlist 
  do
      #add on sub- if not exists
      subj=`fixsubj $subj`

      #loop over sub- and sub-/ses-

    for subjfolder in `ls -d $in_bids/$subj/dwi $in_bids/$subj/ses-${session_ID}/dwi 2> /dev/null`
    do

        subj_sess_dir=${subjfolder%/dwi}
        subj_sess_dir=${subj_sess_dir##$in_bids/}
        if echo $subj_sess_dir | grep -q '/'
        then
            sess=${subj_sess_dir##*/}
            subj_sess_prefix=${subj}_${sess}
        else
            subj_sess_prefix=${subj}
        fi
        echo subjfolder $subjfolder
        echo subj_sess_dir $subj_sess_dir
        echo sess $sess
        echo subj_sess_prefix $subj_sess_prefix


     #check if bedpost results exist
      if [ ! -e $derivatives/bedpost/$subj_sess_prefix/dyads1.nii.gz ]
      then
        echo "Bedpost processing in $derivatives/bedpost/$subj_sess_prefix not complete, skipping ..."
        continue
      fi

	matrix_nii=`ls $derivatives/prepdwi/$subj_sess_dir/dwi/${subj_sess_prefix}*_${matrix}.nii.gz | head -n 1`
echo      $execpath/bin/processProbtrackConnectivity  $derivatives/bedpost probtrack.$atlas $nprobseeds $atlas_label_nii $atlas_label_csv $atlas_space $n_cpus $derivatives/prepdwi/${subj_sess_dir}/dwi/${subj_sess_prefix}_dwi_atlas-${atlas}_connectivity.csv $matrix $matrix_nii $threshold $subj_sess_prefix
      $execpath/bin/processProbtrackConnectivity  $derivatives/bedpost probtrack.$atlas $nprobseeds $atlas_label_nii $atlas_label_csv $atlas_space $n_cpus $derivatives/prepdwi/${subj_sess_dir}/dwi/${subj_sess_prefix}_dwi_atlas-${atlas}_connectivity.csv $matrix $matrix_nii $threshold $subj_sess_prefix

 done #subjsess
  done #subj


   popd

#=====================================================================
#------------------- END STAGE:  participant2 ------------------------
#=====================================================================


 elif [ "$analysis_level" = "participant3" ]
 then




if [ -n "$subject_label_dir" ]
then

 if [ ! -e $subject_label_dir ]
 then
    echo "Input subject label root dir $subject_label_dir does not exist! exiting.."
    exit 1
 fi

 subject_label_dir=`realpath $subject_label_dir`

else

  echo "Required argument for participant3 stage: --subject_label_dir, exiting!" 
  exit 1

fi



if [ ! -n "$subject_label_match" ]
then

  echo "Required argument for participant3 stage: --subject_label_match, exiting!" 
  exit 1

fi

if [ ! -n "$subject_label_name" ]
then

  echo "Required argument for participant3 stage: --subject_label_name, exiting!" 
  exit 1

fi


if [ -n "$subject_label_csv" ]
then

 if [ ! -e $subject_label_csv ]
 then
    echo "Input subject_label_csv $subject_label_csv does not exist! exiting.."
    exit 1
 fi

 subject_label_csv=`realpath $subject_label_csv`

else


  echo "Required argument for participant3 stage: --subject_label_csv, exiting!" 
  exit 1

fi








 #network connectivity matrix
 echo --- Running stage participant3:  connectivity analysis using existing subject-space labels ---


 #need to specify input folder 
 pushd $work_folder
  for subj in $subjlist 
  do
      #add on sub- if not exists
      subj=`fixsubj $subj`

      #loop over sub- and sub-/ses-

    for subjfolder in `ls -d $in_bids/$subj/dwi $in_bids/$subj/ses-${session_ID}/dwi 2> /dev/null`
    do

        subj_sess_dir=${subjfolder%/dwi}
        subj_sess_dir=${subj_sess_dir##$in_bids/}
        if echo $subj_sess_dir | grep -q '/'
        then
            sess=${subj_sess_dir##*/}
            subj_sess_prefix=${subj}_${sess}
        else
            subj_sess_prefix=${subj}
        fi
        echo subjfolder $subjfolder
        echo subj_sess_dir $subj_sess_dir
        echo sess $sess
        echo subj_sess_prefix $subj_sess_prefix




     #check if bedpost results exist
      if [ ! -e $derivatives/bedpost/$subj_sess_prefix/dyads1.nii.gz ]
      then
        echo "Bedpost processing in $derivatives/bedpost/$subj_sess_prefix not complete, skipping ..."
        continue
      fi


      #get path to subject_label_nii file -- works with either: sub-XX/ses-XX/*/*match*  or sub-XX_ses-XX/*/*match*  
      #                                                     or  sub-XX/ses-XX/*match*  or sub-XX_ses-XX/*match*  

      subject_label_nii=`ls ${subject_label_dir}/${subj_sess_dir}/*/${subj_sess_prefix}*${subject_label_match}*.nii.gz ${subject_label_dir}/${subject_label_prefix}/${subj_sess_dir}/*/${subj_sess_prefix}*${subject_label_match}*.nii.gz ${subject_label_dir}/${subj_sess_dir}/${subj_sess_prefix}*${subject_label_match}*.nii.gz ${subject_label_dir}/${subject_label_prefix}/${subj_sess_dir}/${subj_sess_prefix}*${subject_label_match}*.nii.gz 2> /dev/null | head -n 1`


      echo "matching subject_label_nii=$subject_label_nii"

       echo $execpath/bin/processProbtrackConnectivityExistingLabels  $derivatives/bedpost probtrack.subjlabels $nprobseeds $subject_label_nii $subject_label_csv ${subject_label_name} $n_cpus $derivatives/prepdwi/${subj_sess_dir}/dwi/${subj_sess_prefix}_dwi_labels-${subject_label_name}_connectivity.csv $threshold $subj_sess_prefix
       $execpath/bin/processProbtrackConnectivityExistingLabels  $derivatives/bedpost probtrack.subjlabels $nprobseeds $subject_label_nii $subject_label_csv ${subject_label_name} $n_cpus $derivatives/prepdwi/${subj_sess_dir}/dwi/${subj_sess_prefix}_dwi_labels-${subject_label_name}_connectivity.csv $threshold $subj_sess_prefix

 done #subjsess
  done #subj


   popd

#=====================================================================
#------------------- END STAGE:  participant3 ------------------------
#=====================================================================




 else    
  echo "unknown analysis level: $analysis_level"
  
  exit 1
fi


